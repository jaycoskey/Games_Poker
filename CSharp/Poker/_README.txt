Poker hand evaluation overview
Copyright 2011, by Jay Coskey

Design goals: Support the following use cases.
  * Standard conditions:
      - "Simple ranks" are the enumerated list of poker hand names, such as Pair, FullHouse, Flush, etc.,
	    although the internal enum names differ slightly from the standard terms.
      - "Full ranks", which can distinguish, e.g., which of three flush hands beats the other two.
      - Straights can use an ace as either a high-valued or low-valued card.
	  - As one might expect with poker hand-raking software, the ranking methods return to the caller
	    information detailing which cards (including positions in the original hand) were used to form
		the pattern in the "final hand", and which other cards were used to make up the remaining cards,
		or "fill".
  * Common variants:
      - Jokers
      - Wild cards
	  - Hands with more than 5 cards (e.g., in 7-card stud).
  * Uncommon variants:
      - Non-standard ranks (e.g., bobtail flush.  See http://en.wikipedia.org/wiki/Non_standard_poker_hands)
	  - Removal of some standard ranks.  For example, the software should be easily modifiable to remove
	    any individual rank from the evaluation process.  Thus rank determination methods should not presume
		that they will never see hands that match higher-ranked patterns.
	  - Final hands with fewer or more than 5 cards.
  * Non-goals:
      - Actual game.  Gameplay involving interactivity, exchanging cards, etc.
	  - Bugs.  Bugs or other forms of wild cards with limitations on which values and suits they can play as.
	  - Lowest hand.  Evaluation seeking the lowest hand rank, in support of lowball or high-low split.
	  - Wrap-around straights.
	      o To support, have minValue = maxValue - #, with modular wrap-around so that low ace = high ace.
		  o When minValue > maxValue:
		      - Interpret the range (minValue, maxValue) as {x | x <= maxValue || x >= minValue}
			  - Use all the values of the wrap-around straight in the hand's "full rank", instead of using
			    only one, as with the regular straight.

Note: The above design goals, taken as a whole, lead to a rich collection of edge cases.

Design goals: Testing.
  * Some test cases to validate the above features.  Exhaustive validation is not required.
  * Some means of generating random hands.
  * The ability to evaluate a given hand with all the rank determination methods, rather than always 
    stopping upon reaching the first one that returns true.

Implementation notes:
  * Classes Card, TValue, and TSuit are as one might expect.
  * A HandCard differs from Card in that it has fields that record its position in a hand.
      - A HandCard also has a field to record the value that the card is taking on
	   (in the case of an Ace or wild card), but this is not currently being used.
  * The term "wild cards" is used for Cards.  Matching HandCard instances are called "unbound".
  * Each poker hand rank has a qualifying pattern, followed by additional cards, called "fill".
  * Unbound cards that have been used to match a qualifying pattern are called "tamed".
    (The term "bound" could have been used instead, but "tamed" allows for easier searching.)
  * Classes Deck and Hand both derive from CardList.  More precisely, they both derive from
      CardList<CardType> where CardType : ICard.
  * A Deck contains Cards, whereas a Hand contains HandCards.
  * Testing:
      - Static: The class HandTest contains some fixed hand values to be used for testing.
	  - Dynamic: The class HandRandom has some random hand generation methods that can be
	             used to search for hands that do not have the anticipated rank.
				 Note that the hands generated by these methods can, in rare instances,
				 also have higher ranks.  For example, a randomly generated Two Pair hand
				 might also be a Flush, depending on what checks are put in place to prevent
				 such incidents.
  * Hand predicate methods.  The methods that, for each 
  * Hand predicate variable names.  The predicates make use of the these variable name guidelines.
      - Non-wild:i
          o hcsAvail      -- Non-wild candidates for use in matching qualifying pattern.
                   E.g., all 7 spades for a flush.
          o hcsChosen     -- Non-wild cards chosen (from those available) for matching qualifying pattern.
          o fillPlain     -- Non-wild cards used in final hand as high cards supplementing pattern.
      - Wild:
          o hcsTamed      -- Wild cards used to complete qualifying pattern.
          o fillTamed   -- Wild cards used in final hand as high cards supplementing pattern.
      - Non-wild + wild:
          o cardsRank    -- hcsChosen + hcsTamed
		  o cardsFill	 -- fillPlain + fillTamed